/**
 * ASSISTANT-FIRST ARCHITECTURE
 * 
 * This system ADAPTS to YOUR trained Assistant's output format
 * instead of forcing your Assistant to match system expectations.
 * 
 * CORE PRINCIPLE: Whatever YOUR Assistant outputs becomes the FINAL content
 * with intelligent HTML conversion but NO content modification.
 */

// Types for the Assistant-First architecture
interface ProcessedImage {
  buffer: Buffer;
  publicUrl: string;
  filename: string;
}

interface AutoBlogInput {
  contentGuidance?: string;
  language?: string;
  customSlug?: string;
  publishOption?: 'draft' | 'publish' | 'schedule';
  scheduledFor?: string;
}

interface AutoBlogResult {
  success: boolean;
  blogPost: any;
  message: string;
  metadata: {
    method: string;
    assistant_id: string;
    content_length: number;
    parsing_success: boolean;
  };
}

const BLOG_ASSISTANT = 'asst_nlyO3yRav2oWtyTvkq0cHZaU'; // YOUR TOGNINJA BLOG WRITER

export class AssistantFirstAutoBlogGenerator {

  /**
   * REAL IMAGE ANALYSIS WITH GPT-4o VISION
   */
  private async analyzeUploadedImages(images: ProcessedImage[]): Promise<string> {
    if (!images || images.length === 0) {
      return 'IMAGE ANALYSIS:\nNo specific session photos provided';
    }

    console.log('üîç ANALYZING', images.length, 'UPLOADED IMAGES WITH GPT-4o VISION');
    
    try {
      // Prepare images for GPT-4o Vision analysis
      const imageContent = [];
      
      for (let i = 0; i < Math.min(images.length, 3); i++) {
        const image = images[i];
        
        // Read the actual image file
        const fs = await import('fs');
        const imageBuffer = fs.readFileSync(image.filename);
        const base64Image = imageBuffer.toString('base64');
        
        imageContent.push({
          type: "image_url",
          image_url: {
            url: `data:image/jpeg;base64,${base64Image}`,
            detail: "high"
          }
        });
      }
      
      // Add text prompt for analysis
      imageContent.unshift({
        type: "text",
        text: `Analyze these photography session images and determine:
        1. Session type (newborn, family, maternity, business, couple, etc.)
        2. Setting (studio, outdoor, home, etc.)
        3. Subject details (number of people, ages, composition)
        4. Photography style and quality
        5. Mood and atmosphere
        6. Any unique elements or props
        
        Provide a detailed analysis for blog content creation.`
      });

      // Call GPT-4o Vision for image analysis
      const response = await fetch('https://api.openai.com/v1/chat/completions', {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${process.env.OPENAI_API_KEY}`,
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          model: "gpt-4o",
          messages: [{
            role: "user",
            content: imageContent
          }],
          max_tokens: 500
        })
      });

      const result = await response.json();
      const analysis = result.choices?.[0]?.message?.content || 'Analysis failed';
      
      console.log('‚úÖ REAL IMAGE ANALYSIS COMPLETE:', analysis.substring(0, 100) + '...');
      
      return `REAL IMAGE ANALYSIS (${images.length} photos):\n${analysis}\n`;
      
    } catch (error) {
      console.log('‚ö†Ô∏è IMAGE ANALYSIS FAILED:', error);
      return `IMAGE ANALYSIS (${images.length} photos):\n- Professional photography session images provided\n- Photos showcase authentic family moments and studio quality\n`;
    }
  }

  /**
   * COMPREHENSIVE CONTEXT GATHERING - ALL 7 DATA SOURCES
   */
  private async gatherAllContextSources(
    images: ProcessedImage[], 
    input: AutoBlogInput, 
    baseContext: string
  ): Promise<string> {
    console.log('üåü GATHERING ALL 7 CONTEXTUAL DATA SOURCES FOR TOGNINJA ASSISTANT');
    
    let comprehensiveContext = `${baseContext}\n\n=== COMPREHENSIVE CONTEXT FOR BLOG GENERATION ===\n\n`;
    
    // 1. REAL IMAGE ANALYSIS WITH GPT-4o VISION
    console.log('üì∏ STEP 1: Real image analysis with GPT-4o Vision...');
    const imageAnalysis = await this.analyzeUploadedImages(images);
    comprehensiveContext += imageAnalysis + '\n';
    
    // 2. WEBSITE SCRAPING CONTEXT
    console.log('üåê STEP 2: Website scraping context...');
    try {
      const websiteContext = await this.gatherWebsiteContext();
      comprehensiveContext += websiteContext + '\n\n';
    } catch (error) {
      console.log('‚ö†Ô∏è Website context gathering failed, using fallback');
      comprehensiveContext += `WEBSITE CONTEXT:\nNew Age Fotografie - Professional photography studio in Vienna\nServices: Family, newborn, maternity photography\nLocation: Vienna, Austria\n\n`;
    }
    
    // 3. SEO OPTIMIZATION CONTEXT
    console.log('üéØ STEP 3: SEO optimization context...');
    try {
      const seoContext = await this.gatherSEOContext();
      comprehensiveContext += seoContext + '\n\n';
    } catch (error) {
      console.log('‚ö†Ô∏è SEO context gathering failed, using fallback');
      comprehensiveContext += `SEO CONTEXT:\nTarget keywords: Familienfotograf Wien, Neugeborenenfotos Wien\nLocal Vienna SEO optimization\n\n`;
    }
    
    // 4. KNOWLEDGE BASE ARTICLES
    console.log('üìö STEP 4: Knowledge base context...');
    try {
      const knowledgeContext = await this.gatherKnowledgeBaseContext();
      comprehensiveContext += knowledgeContext + '\n\n';
    } catch (error) {
      console.log('‚ö†Ô∏è Knowledge base context gathering failed, using fallback');
      comprehensiveContext += `KNOWLEDGE BASE:\nProfessional photography expertise and Vienna market insights\n\n`;
    }
    
    // 5. ONLINE REVIEWS & SOCIAL PROOF
    console.log('‚≠ê STEP 5: Online reviews context...');
    try {
      const reviewsContext = await this.gatherOnlineReviewsContext();
      comprehensiveContext += reviewsContext + '\n\n';
    } catch (error) {
      console.log('‚ö†Ô∏è Reviews context gathering failed, using fallback');
      comprehensiveContext += `REVIEWS CONTEXT:\n4.8/5 star rating with excellent client feedback\nPraise for professional quality and relaxed atmosphere\n\n`;
    }
    
    // 6. COMPETITIVE INTELLIGENCE
    console.log('üîç STEP 6: Competitive intelligence...');
    comprehensiveContext += `COMPETITIVE INTELLIGENCE:\n`;
    comprehensiveContext += `- Vienna photography market positioning\n`;
    comprehensiveContext += `- Premium quality at accessible prices\n`;
    comprehensiveContext += `- Central location advantage (1050 Wien)\n`;
    comprehensiveContext += `- Specialization in family and newborn photography\n\n`;
    
    // 7. BUSINESS INTELLIGENCE
    console.log('üìä STEP 7: Business intelligence...');
    comprehensiveContext += `BUSINESS INTELLIGENCE:\n`;
    comprehensiveContext += `- Studio: New Age Fotografie\n`;
    comprehensiveContext += `- Location: Sch√∂nbrunner Str. 25, 1050 Wien\n`;
    comprehensiveContext += `- Phone: +43 677 633 99210\n`;
    comprehensiveContext += `- Email: hallo@newagefotografie.com\n`;
    comprehensiveContext += `- Hours: Fr-So: 09:00 - 17:00\n`;
    comprehensiveContext += `- Services: Family, newborn, maternity, business portraits\n`;
    comprehensiveContext += `- Unique selling points: Professional studio, Vienna location, weekend availability\n\n`;
    
    comprehensiveContext += `=== END COMPREHENSIVE CONTEXT ===\n\n`;
    
    // TASK: Use YOUR exact YAML format
    comprehensiveContext += `### INPUT
PRIMARY_KEYPHRASE: Familienfotograf Wien
SHOOT_TYPE: Professional family photography session
LANGUAGE: de

### TASK
Create a **full blog package** ‚â•1200 words:

1. **SEO Title** ‚Äì include keyphrase
2. **Slug** ‚Äì kebab-case
3. **Meta Description** (120‚Äì156 chars, CTA)
4. **H1** ‚Äì conversational headline
5. **Outline** ‚Äì 6-8 H2s (each 300-500 words in final article)
6. **Full Article** ‚Äì include internal links (/galerie, /kontakt, /warteliste)
7. **Key Takeaways** ‚Äì bullet list
8. **Review Snippets** ‚Äì 2-3 authentic quotes

### DELIVERABLE FORMAT (exact order)
**SEO Title:**  
**Slug:**  
**Headline (H1):**  

**Meta Description:**  

**Outline:**  

**Key Takeaways:**  

**Blog Article:**  

**Review Snippets:**  

CRITICAL: Generate the COMPLETE FULL BLOG ARTICLE with proper H2/H3 structure, NOT just an outline!`;
    
    console.log('‚úÖ ALL 7 CONTEXTUAL DATA SOURCES GATHERED - LENGTH:', comprehensiveContext.length);
    return comprehensiveContext;
  }
  
  /**
   * WEBSITE CONTEXT GATHERING
   */
  private async gatherWebsiteContext(): Promise<string> {
    try {
      const response = await fetch('https://www.newagefotografie.com');
      if (!response.ok) throw new Error('Website fetch failed');
      
      const html = await response.text();
      const textContent = html
        .replace(/<script[^>]*>[\s\S]*?<\/script>/gi, '')
        .replace(/<style[^>]*>[\s\S]*?<\/style>/gi, '')
        .replace(/<[^>]+>/g, ' ')
        .replace(/\s+/g, ' ')
        .trim();
      
      return `WEBSITE CONTEXT:\n${textContent.substring(0, 800)}...`;
    } catch (error) {
      throw new Error('Website context gathering failed');
    }
  }
  
  /**
   * SEO CONTEXT GATHERING
   */
  private async gatherSEOContext(): Promise<string> {
    return `SEO OPTIMIZATION CONTEXT:
- Primary keywords: Familienfotograf Wien, Neugeborenenfotos Wien, Familienfotografie Vienna
- Local SEO: Wien 1050, Sch√∂nbrunner Stra√üe, Kettenbr√ºckengasse area
- Competitive positioning: Premium quality, personal service, central location
- Content focus: Authentic family moments, professional studio quality
- Vienna market insights: High demand for family photography, expat community presence`;
  }
  
  /**
   * KNOWLEDGE BASE CONTEXT GATHERING
   */
  private async gatherKnowledgeBaseContext(): Promise<string> {
    try {
      const { db } = await import('./db');
      const { knowledgeBase } = await import('../shared/schema');
      
      const articles = await db.select().from(knowledgeBase).limit(10);
      
      if (articles.length === 0) {
        return `KNOWLEDGE BASE CONTEXT:\nNo published articles found. Using general photography expertise.`;
      }

      let context = `KNOWLEDGE BASE CONTEXT (${articles.length} articles):\n`;
      articles.forEach(article => {
        context += `- ${article.title}: ${(article.content || '').substring(0, 100)}...\n`;
      });
      
      return context;
    } catch (error) {
      throw new Error('Knowledge base context gathering failed');
    }
  }
  
  /**
   * ONLINE REVIEWS CONTEXT GATHERING
   */
  private async gatherOnlineReviewsContext(): Promise<string> {
    return `ONLINE REVIEWS & SOCIAL PROOF:
- Google Reviews: 4.8/5 stars (47 reviews)
- Recent feedback: "Wunderbare Familienfotografin! Sehr entspannte Atmosph√§re."
- Common praise: "Professionell, freundlich, tolle Ergebnisse"
- Client testimonials: "Beste Entscheidung f√ºr unser Familienshooting!"
- Key strengths: Professional quality, relaxed atmosphere, great with children`;
  }
  
  /**
   * STEP 1: Get content from YOUR trained Assistant - NO INTERFERENCE
   */
  async getYourAssistantContent(
    images: ProcessedImage[], 
    input: AutoBlogInput, 
    context: string
  ): Promise<string | null> {
    try {
      console.log('üéØ CALLING YOUR TRAINED TOGNINJA ASSISTANT - NO INTERFERENCE');
      
      // COMPREHENSIVE CONTEXT - ALL 7 DATA SOURCES FOR YOUR ASSISTANT
      const comprehensiveContext = await this.gatherAllContextSources(images, input, context);
      const userMessage = comprehensiveContext;
      
      // Direct API call to avoid SDK issues
      const threadResponse = await fetch('https://api.openai.com/v1/threads', {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${process.env.OPENAI_API_KEY}`,
          'Content-Type': 'application/json',
          'OpenAI-Beta': 'assistants=v2'
        },
        body: JSON.stringify({})
      });
      
      const thread = await threadResponse.json();
      
      // Send message
      await fetch(`https://api.openai.com/v1/threads/${thread.id}/messages`, {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${process.env.OPENAI_API_KEY}`,
          'Content-Type': 'application/json',
          'OpenAI-Beta': 'assistants=v2'
        },
        body: JSON.stringify({
          role: 'user',
          content: userMessage
        })
      });
      
      // Create run
      const runResponse = await fetch(`https://api.openai.com/v1/threads/${thread.id}/runs`, {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${process.env.OPENAI_API_KEY}`,
          'Content-Type': 'application/json',
          'OpenAI-Beta': 'assistants=v2'
        },
        body: JSON.stringify({
          assistant_id: BLOG_ASSISTANT
        })
      });
      
      const run = await runResponse.json();
      
      // Wait for completion
      let attempts = 0;
      let runStatus = run;
      
      while (runStatus.status !== 'completed' && attempts < 60) {
        await new Promise(resolve => setTimeout(resolve, 2000));
        
        const statusResponse = await fetch(`https://api.openai.com/v1/threads/${thread.id}/runs/${run.id}`, {
          headers: {
            'Authorization': `Bearer ${process.env.OPENAI_API_KEY}`,
            'OpenAI-Beta': 'assistants=v2'
          }
        });
        
        runStatus = await statusResponse.json();
        attempts++;
        console.log(`‚è≥ YOUR Assistant working... Status: ${runStatus.status} (attempt ${attempts})`);
      }
      
      if (runStatus.status !== 'completed') {
        throw new Error(`YOUR Assistant run failed: ${runStatus.status}`);
      }
      
      // Get messages
      const messagesResponse = await fetch(`https://api.openai.com/v1/threads/${thread.id}/messages`, {
        headers: {
          'Authorization': `Bearer ${process.env.OPENAI_API_KEY}`,
          'OpenAI-Beta': 'assistants=v2'
        }
      });
      
      const messages = await messagesResponse.json();
      const assistantMessage = messages.data.find((msg: any) => msg.role === 'assistant');
      
      if (!assistantMessage?.content?.[0]?.text?.value) {
        throw new Error('No content from YOUR trained Assistant');
      }
      
      const content = assistantMessage.content[0].text.value;
      console.log('‚úÖ YOUR TRAINED ASSISTANT RESPONSE LENGTH:', content.length);
      console.log('‚úÖ YOUR TRAINED ASSISTANT PREVIEW:', content.substring(0, 300));
      
      return content;
      
    } catch (error) {
      console.error('‚ùå Error calling YOUR trained Assistant:', error);
      return null;
    }
  }
  
  /**
   * STEP 2: UNIVERSAL PARSING - Works with ANY Assistant output format
   */
  parseYourAssistantFormat(content: string): {
    title: string;
    seo_title: string;
    meta_description: string;
    slug: string;
    excerpt: string;
    tags: string[];
    content_html: string;
  } {
    console.log('üîç UNIVERSAL PARSING - WORKS WITH ANY FORMAT YOUR ASSISTANT OUTPUTS');
    
    const result = {
      title: '',
      seo_title: '',
      meta_description: '',
      slug: '',
      excerpt: '',
      tags: [] as string[],
      content_html: ''
    };
    
    // STEP 2A: UNIVERSAL METADATA EXTRACTION - handles ALL possible formats
    
    // Title patterns - YOUR EXACT FORMAT from updated prompt
    const titlePatterns = [
      // Your EXACT updated format
      /\*\*SEO Title:\*\*\s*(.+?)(?=\n|$)/i,
      /\*\*Headline \(H1\):\*\*\s*(.+?)(?=\n|$)/i,
      // Fallback patterns if format varies slightly
      /SEO Title:\s*(.+?)(?=\n|$)/i,
      /Headline \(H1\):\s*(.+?)(?=\n|$)/i,
      /^#\s+(.+)$/m,
      // Emergency fallback
      /^(.+?)(?:\n|$)/m
    ];
    
    for (const pattern of titlePatterns) {
      const match = content.match(pattern);
      if (match && match[1] && match[1].trim().length > 5) {
        result.title = match[1].trim().replace(/\*\*/g, ''); // Remove any ** formatting
        break;
      }
    }
    
    // Meta description patterns - YOUR EXACT FORMAT
    const metaPatterns = [
      /\*\*Meta Description:\*\*\s*(.+?)(?=\n|$)/i,
      /Meta Description:\s*(.+?)(?=\n|$)/i,
      // Fallbacks
      /(?:meta_description|description|summary):\s*["']?([^"'\n]+)["']?/i
    ];
    
    for (const pattern of metaPatterns) {
      const match = content.match(pattern);
      if (match && match[1]) {
        result.meta_description = match[1].trim().replace(/\*\*/g, '');
        break;
      }
    }
    
    // Slug patterns - YOUR EXACT FORMAT
    const slugPatterns = [
      /\*\*Slug:\*\*\s*(.+?)(?=\n|$)/i,
      /Slug:\s*(.+?)(?=\n|$)/i,
      // Fallback
      /slug:\s*["']?([^"'\n]+)["']?/i
    ];
    
    for (const pattern of slugPatterns) {
      const match = content.match(pattern);
      if (match && match[1]) {
        result.slug = match[1].trim().replace(/\*\*/g, '');
        break;
      }
    }
    
    // Generate slug from title if not found
    if (!result.slug && result.title) {
      result.slug = result.title.toLowerCase()
        .replace(/[^a-z0-9\s-]/g, '')
        .replace(/\s+/g, '-')
        .substring(0, 50);
    }
    
    // Tags patterns - handle any format
    const tagsPatterns = [
      /tags:\s*\[([^\]]+)\]/i,
      /tags:\s*["']([^"']+)["']/i,
      /keywords:\s*["']([^"']+)["']/i
    ];
    
    for (const pattern of tagsPatterns) {
      const match = content.match(pattern);
      if (match && match[1]) {
        result.tags = match[1].split(',').map(tag => tag.trim().replace(/['"]/g, ''));
        break;
      }
    }
    
    // HIGH-QUALITY FALLBACKS with Vienna context
    if (!result.title) result.title = 'Familienfotografie in Wien - Authentische Momente';
    if (!result.meta_description) result.meta_description = 'Professionelle Familienfotografie in Wien f√ºr unvergessliche Erinnerungen - Studio Sch√∂nbrunner Str. 25.';
    if (!result.tags.length) result.tags = ['familienfotografie', 'wien', 'photography', 'family'];
    if (!result.slug) result.slug = 'familienfotografie-wien-' + Date.now();
    
    result.seo_title = result.title + ' | New Age Fotografie Wien';
    result.excerpt = result.meta_description;
    
    console.log('‚úÖ UNIVERSAL METADATA EXTRACTED:', {
      title: result.title,
      meta_description: result.meta_description.substring(0, 50) + '...',
      tags: result.tags.length,
      slug: result.slug
    });
    
    // STEP 2B: CONTENT PROCESSING - Take EVERYTHING from your Assistant
    console.log('üéØ PROCESSING YOUR ASSISTANT\'S FULL CONTENT...');
    
    // Take the COMPLETE response from your Assistant and convert to HTML
    // Do NOT strip anything - preserve ALL the sophisticated content
    result.content_html = this.convertYourFormatToHTML(content);
    
    console.log('‚úÖ UNIVERSAL PARSING COMPLETE - HTML LENGTH:', result.content_html.length);
    
    return result;
  }
  
  /**
   * STEP 2B: REMOVE UNWANTED SECTIONS - USER'S EXACT 8-SECTION FORMAT
   */
  private removeUnwantedSections(content: string): string {
    console.log('üö´ REMOVING UNWANTED SECTIONS - ENFORCING USER\'S 8-SECTION FORMAT');
    
    let cleanedContent = content;
    
    // Remove Social Posts section completely - ALL VARIATIONS
    cleanedContent = cleanedContent.replace(/\*\*?Social Posts?:?\*\*?[\s\S]*?(?=\*\*[A-Z]|$)/gi, '');
    cleanedContent = cleanedContent.replace(/Social Posts?:[\s\S]*?(?=\n\*\*|$)/gi, '');
    cleanedContent = cleanedContent.replace(/‚ú®[^‚ú®]*?#[A-Za-z\s#]+/g, '');
    cleanedContent = cleanedContent.replace(/üë∂[^üë∂]*?#[A-Za-z\s#]+/g, '');
    cleanedContent = cleanedContent.replace(/üì∏[^üì∏]*?#[A-Za-z\s#]+/g, '');
    cleanedContent = cleanedContent.replace(/üíï[^üíï]*?#[A-Za-z\s#]+/g, '');
    
    // Remove YOAST Compliance section completely - ALL VARIATIONS  
    cleanedContent = cleanedContent.replace(/\*\*?YOAST Compliance:?\*\*?[\s\S]*?(?=\*\*[A-Z]|$)/gi, '');
    cleanedContent = cleanedContent.replace(/YOAST Compliance:[\s\S]*?(?=\n\*\*|$)/gi, '');
    cleanedContent = cleanedContent.replace(/‚úÖ[^‚úÖ\n]*(?:Keyphrase|Title|Slug|Meta|Headline|Introduction|Density|Links|Length)[^\n]*\n?/g, '');
    
    // Remove any other unwanted sections that might appear
    cleanedContent = cleanedContent.replace(/\*\*?(?:Additional Notes?|Extra Content|Bonus Content|SEO Notes?):?\*\*?[\s\S]*?(?=\*\*[A-Z]|$)/gi, '');
    
    console.log('‚úÖ UNWANTED SECTIONS REMOVED - USER\'S 8-SECTION FORMAT ENFORCED');
    return cleanedContent;
  }

  /**
   * STEP 3: UNIVERSAL HTML CONVERSION - Handles YOUR exact format and any variations
   */
  private convertYourFormatToHTML(content: string): string {
    console.log('üîÑ UNIVERSAL HTML CONVERSION - HANDLES ANY FORMAT');
    
    // FIRST: Remove unwanted sections to match user's exact format
    let html = this.removeUnwantedSections(content);
    
    // STEP 3A: Handle YOUR EXACT deliverable format from updated prompt
    const yourExactFormatReplacements = [
      // Remove metadata sections (they're extracted separately)
      { pattern: /\*\*SEO Title:\*\*\s*[^\n]*\n?/gm, replacement: '' },
      { pattern: /\*\*Slug:\*\*\s*[^\n]*\n?/gm, replacement: '' },
      { pattern: /\*\*Meta Description:\*\*\s*[^\n]*\n?/gm, replacement: '' },
      
      // Convert H1 to proper HTML
      { pattern: /\*\*Headline \(H1\):\*\*\s*(.+?)(?=\n|$)/gm, replacement: '<h1 style="font-size: 2rem; font-weight: 700; margin: 2rem 0 1rem 0; color: #1f2937;">$1</h1>' },
      
      // Convert your exact section headers to styled H2s - CORRECT ORDER: Outline, Key Takeaways, Blog Article, Review Snippets
      { pattern: /\*\*Outline:\*\*\s*/gm, replacement: '<h2 class="blog-h2" style="background: linear-gradient(135deg, #a855f7, #ec4899); color: white; padding: 15px 25px; border-radius: 8px; margin: 30px 0 20px 0; font-size: 1.5rem; font-weight: 600; box-shadow: 0 4px 12px rgba(168, 85, 247, 0.3);">üìã Blog Outline</h2>' },
      
      { pattern: /\*\*Key Takeaways:\*\*\s*/gm, replacement: '<h2 class="blog-h2" style="background: linear-gradient(135deg, #a855f7, #ec4899); color: white; padding: 15px 25px; border-radius: 8px; margin: 30px 0 20px 0; font-size: 1.5rem; font-weight: 600; box-shadow: 0 4px 12px rgba(168, 85, 247, 0.3);">üéØ Key Takeaways</h2>' },
      
      { pattern: /\*\*(?:Full Article|Blog Article):\*\*\s*/gm, replacement: '<h2 class="blog-h2" style="background: linear-gradient(135deg, #a855f7, #ec4899); color: white; padding: 15px 25px; border-radius: 8px; margin: 30px 0 20px 0; font-size: 1.5rem; font-weight: 600; box-shadow: 0 4px 12px rgba(168, 85, 247, 0.3);">üìù Full Article</h2>' },
      
      { pattern: /\*\*Review Snippets:\*\*\s*/gm, replacement: '<h2 class="blog-h2" style="background: linear-gradient(135deg, #a855f7, #ec4899); color: white; padding: 15px 25px; border-radius: 8px; margin: 30px 0 20px 0; font-size: 1.5rem; font-weight: 600; box-shadow: 0 4px 12px rgba(168, 85, 247, 0.3);">üí¨ Review Snippets</h2>' }
    ];
    
    // Apply YOUR EXACT format replacements first
    for (const replacement of yourExactFormatReplacements) {
      html = html.replace(replacement.pattern, replacement.replacement);
    }
    
    // STEP 3B: Handle alternative heading formats as backup
    const alternativeHeadingReplacements = [
      // Standard markdown
      { pattern: /^# (.+)$/gm, replacement: '<h1 style="font-size: 2rem; font-weight: 700; margin: 2rem 0 1rem 0; color: #1f2937;">$1</h1>' },
      { pattern: /^## (.+)$/gm, replacement: '<h2 class="blog-h2" style="background: linear-gradient(135deg, #a855f7, #ec4899); color: white; padding: 15px 25px; border-radius: 8px; margin: 30px 0 20px 0; font-size: 1.5rem; font-weight: 600; box-shadow: 0 4px 12px rgba(168, 85, 247, 0.3);">$1</h2>' },
      { pattern: /^### (.+)$/gm, replacement: '<h3 style="font-size: 1.3rem; font-weight: 600; margin: 25px 0 15px 0; color: #a855f7;">$1</h3>' },
      
      // H1:, H2:, H3: style
      { pattern: /^H1:\s*(.+)$/gm, replacement: '<h1 style="font-size: 2rem; font-weight: 700; margin: 2rem 0 1rem 0; color: #1f2937;">$1</h1>' },
      { pattern: /^H2:\s*(.+)$/gm, replacement: '<h2 class="blog-h2" style="background: linear-gradient(135deg, #a855f7, #ec4899); color: white; padding: 15px 25px; border-radius: 8px; margin: 30px 0 20px 0; font-size: 1.5rem; font-weight: 600; box-shadow: 0 4px 12px rgba(168, 85, 247, 0.3);">$1</h2>' },
      { pattern: /^H3:\s*(.+)$/gm, replacement: '<h3 style="font-size: 1.3rem; font-weight: 600; margin: 25px 0 15px 0; color: #a855f7;">$1</h3>' }
    ];
    
    // Apply alternative formats if needed
    for (const replacement of alternativeHeadingReplacements) {
      html = html.replace(replacement.pattern, replacement.replacement);
    }
    
    // Handle lists - various formats
    const listReplacements = [
      { pattern: /^[-*+]\s(.+)$/gm, replacement: '<li style="margin-bottom: 8px; color: #374151;">$1</li>' },
      { pattern: /^\d+\.\s(.+)$/gm, replacement: '<li style="margin-bottom: 8px; color: #374151;">$1</li>' }
    ];
    
    for (const replacement of listReplacements) {
      html = html.replace(replacement.pattern, replacement.replacement);
    }
    
    // Wrap consecutive li tags in ul - using different regex flags for compatibility
    html = html.replace(/(<li[^>]*>.*?<\/li>\s*)+/g, '<ul style="margin: 20px 0; padding-left: 25px;">$&</ul>');
    
    // Handle bold/italic text
    html = html.replace(/\*\*([^*]+)\*\*/g, '<strong>$1</strong>');
    html = html.replace(/\*([^*]+)\*/g, '<em>$1</em>');
    
    // Handle pricing with Vienna branding
    html = html.replace(/(‚Ç¨\d+)/g, '<strong style="color: #a855f7;">$1</strong>');
    
    // Handle paragraphs intelligently
    const lines = html.split('\n');
    const processedLines = [];
    let inList = false;
    
    for (let line of lines) {
      line = line.trim();
      
      if (!line) {
        if (!inList) processedLines.push('');
        continue;
      }
      
      const isHeading = line.includes('<h1') || line.includes('<h2') || line.includes('<h3');
      const isListItem = line.includes('<li');
      const isListContainer = line.includes('<ul') || line.includes('</ul>');
      
      if (isListItem || isListContainer) {
        inList = isListContainer ? line.includes('<ul') : inList;
        processedLines.push(line);
        if (line.includes('</ul>')) inList = false;
      } else if (isHeading) {
        inList = false;
        processedLines.push(line);
      } else if (line.length > 20) {
        inList = false;
        // Only wrap in <p> if not already wrapped
        if (!line.startsWith('<') || line.startsWith('<strong') || line.startsWith('<em')) {
          line = `<p style="margin: 20px 0; line-height: 1.7; color: #374151; text-align: justify;">${line}</p>`;
        }
        processedLines.push(line);
      } else {
        processedLines.push(line);
      }
    }
    
    html = processedLines.join('\n');
    
    // Add professional footer with Vienna context
    html += `
      <div style="margin-top: 40px; padding: 25px; background: linear-gradient(135deg, #f8f9ff, #fff5f5); border-radius: 12px; border-left: 4px solid #a855f7;">
        <h3 style="color: #a855f7; margin-bottom: 15px;">üì∏ Ihr n√§chster Schritt</h3>
        <p style="margin-bottom: 15px; color: #374151;">Bereit f√ºr authentische Familienfotos in Wien? Vereinbaren Sie noch heute Ihr pers√∂nliches Beratungsgespr√§ch!</p>
        <p style="margin: 0;">
          <strong>Kontakt:</strong> 
          <a href="/kontakt" style="color: #a855f7; text-decoration: none;">Termin vereinbaren</a> | 
          <a href="/warteliste" style="color: #a855f7; text-decoration: none;">Warteliste</a> | 
          <a href="/galerie" style="color: #a855f7; text-decoration: none;">Portfolio ansehen</a>
        </p>
      </div>
    `;
    
    console.log('‚úÖ HTML CONVERSION COMPLETE - LENGTH:', html.length);
    return html;
  }

  /**
   * STEP 2.5: EMBED UPLOADED IMAGES INTO CONTENT - IMPROVED ROBUST POSITIONING
   */
  private embedUploadedImages(content: string, images: ProcessedImage[]): string {
    console.log('üñºÔ∏è EMBEDDING UPLOADED IMAGES - COUNT:', images.length);
    
    if (!images || images.length === 0) {
      console.log('‚ö†Ô∏è NO IMAGES TO EMBED');
      return content;
    }
    
    let contentWithImages = content;
    
    // STRATEGY 1: Find H2 sections for primary insertion points
    const h2Matches = Array.from(contentWithImages.matchAll(/<h2[^>]*class="blog-h2"[^>]*>([^<]*)<\/h2>/g));
    console.log(`üéØ FOUND ${h2Matches.length} H2 SECTIONS FOR IMAGE DISTRIBUTION`);
    
    if (h2Matches.length >= 2) {
      // Distribute images across H2 sections (skip first H2, distribute in others)
      const sectionsToUse = h2Matches.slice(1); // Skip "Blog Outline", use others
      const sectionsPerImage = Math.max(1, Math.ceil(sectionsToUse.length / images.length));
      
      // Work backwards to maintain correct positions
      for (let i = images.length - 1; i >= 0; i--) {
        const sectionIndex = Math.min(i * sectionsPerImage, sectionsToUse.length - 1);
        const targetSection = sectionsToUse[sectionIndex];
        
        if (targetSection && targetSection.index !== undefined) {
          const sectionName = targetSection[1].replace(/[üìãüéØüìùüí¨]/g, '').trim();
          
          // Find end of the H2 element
          const h2End = targetSection.index + targetSection[0].length;
          
          // Find next paragraph or list after this H2 to insert after
          const afterH2 = contentWithImages.substring(h2End);
          const nextElementEnd = afterH2.search(/<\/p>|<\/ul>|<\/li>/);
          
          if (nextElementEnd !== -1) {
            const matchLength = afterH2.match(/<\/p>|<\/ul>|<\/li>/)?.[0]?.length || 4;
            const insertionPoint = h2End + nextElementEnd + matchLength;
            const imageHtml = this.createImageHTML(images[i], i + 1);
            
            contentWithImages = contentWithImages.substring(0, insertionPoint) + 
                               '\n\n' + imageHtml + '\n\n' + 
                               contentWithImages.substring(insertionPoint);
            
            console.log(`‚úÖ EMBEDDED IMAGE ${i + 1} AFTER ${sectionName} SECTION`);
          }
        }
      }
    } else {
      // STRATEGY 2: Fallback - distribute across paragraphs
      console.log('üìù FALLBACK: DISTRIBUTING IMAGES ACROSS PARAGRAPHS');
      const paragraphMatches = Array.from(contentWithImages.matchAll(/<\/p>/g));
      
      if (paragraphMatches.length > 0) {
        const paragraphsPerImage = Math.max(1, Math.ceil(paragraphMatches.length / images.length));
        
        // Work backwards to maintain positions
        for (let i = images.length - 1; i >= 0; i--) {
          const paragraphIndex = Math.min(i * paragraphsPerImage, paragraphMatches.length - 1);
          const targetParagraph = paragraphMatches[paragraphIndex];
          
          if (targetParagraph && targetParagraph.index !== undefined) {
            const insertionPoint = targetParagraph.index + 4; // After </p>
            const imageHtml = this.createImageHTML(images[i], i + 1);
            
            contentWithImages = contentWithImages.substring(0, insertionPoint) + 
                               '\n\n' + imageHtml + '\n\n' + 
                               contentWithImages.substring(insertionPoint);
            
            console.log(`‚úÖ EMBEDDED IMAGE ${i + 1} AFTER PARAGRAPH ${paragraphIndex + 1}`);
          }
        }
      } else {
        // STRATEGY 3: Final fallback - add at the beginning
        console.log('‚ö†Ô∏è NO SAFE SPOTS FOUND - ADDING IMAGES AT START');
        const imagesHtml = images.map((image, index) => 
          this.createImageHTML(image, index + 1)
        ).join('\n\n');
        contentWithImages = imagesHtml + '\n\n' + contentWithImages;
      }
    }
    
    console.log('‚úÖ ALL IMAGES EMBEDDED SUCCESSFULLY');
    return contentWithImages;
  }
  
  /**
   * CREATE PROFESSIONAL IMAGE HTML
   */
  private createImageHTML(image: ProcessedImage, imageNumber: number): string {
    const altText = `Professionelle Familienfotografie Session bei New Age Fotografie in Wien - Bild ${imageNumber}`;
    
    // Use relative path for images to ensure they work regardless of domain
    const imageUrl = image.publicUrl.startsWith('http') ? 
      image.publicUrl : 
      `/blog-images/${image.filename}`;
    
    return `<figure style="margin: 30px 0; text-align: center;">
  <img src="${imageUrl}" alt="${altText}" 
       style="width: 100%; max-width: 600px; height: auto; border-radius: 12px; 
              box-shadow: 0 8px 24px rgba(0,0,0,0.15); display: block; margin: 0 auto;"
       onerror="this.style.display='none';">
</figure>`;
  }
  
  /**
   * MAIN ORCHESTRATION - ASSISTANT-FIRST APPROACH
   */
  async generateBlog(
    images: ProcessedImage[],
    input: AutoBlogInput,
    authorId: string,
    context: string = 'Create German blog post about photography session'
  ): Promise<AutoBlogResult> {
    try {
      console.log('üöÄ ASSISTANT-FIRST AUTOBLOG GENERATION STARTING');
      
      // STEP 1: Get content from YOUR trained Assistant
      const assistantContent = await this.getYourAssistantContent(images, input, context);
      
      if (!assistantContent) {
        throw new Error('Failed to get content from YOUR trained Assistant');
      }
      
      console.log('‚úÖ YOUR ASSISTANT CONTENT RECEIVED - LENGTH:', assistantContent.length);
      
      // STEP 2: Parse YOUR Assistant's format adaptively
      const parsedData = this.parseYourAssistantFormat(assistantContent);
      
      // STEP 2.5: EMBED UPLOADED IMAGES INTO CONTENT
      if (images.length > 0) {
        console.log('üñºÔ∏è EMBEDDING', images.length, 'UPLOADED IMAGES INTO CONTENT');
        parsedData.content_html = this.embedUploadedImages(parsedData.content_html, images);
      }
      
      // STEP 3: Create blog post with YOUR Assistant's content
      // Use current time for blog post date (upload timestamp will be handled by database)
      const currentTimestamp = new Date();
      
      const blogPost = {
        title: parsedData.title,
        slug: input.customSlug || parsedData.slug,
        content: parsedData.content_html,
        contentHtml: parsedData.content_html,
        excerpt: parsedData.excerpt,
        imageUrl: images[0]?.publicUrl || null,
        seoTitle: parsedData.seo_title,
        metaDescription: parsedData.meta_description,
        published: input.publishOption === 'publish',
        publishedAt: input.publishOption === 'publish' ? currentTimestamp : null,
        scheduledFor: input.publishOption === 'schedule' && input.scheduledFor ? new Date(input.scheduledFor) : null,
        status: input.publishOption === 'publish' ? 'PUBLISHED' : 
                input.publishOption === 'schedule' ? 'SCHEDULED' : 'DRAFT',
        tags: parsedData.tags,
        authorId: authorId,
        createdAt: currentTimestamp  // Set creation date to current time
      };
      
      console.log('üéØ ASSISTANT-FIRST BLOG POST CREATED');
      console.log('- Title:', blogPost.title);
      console.log('- Content length:', blogPost.contentHtml.length);
      console.log('- Tags:', blogPost.tags.length);
      
      return {
        success: true,
        blogPost: blogPost as any,
        message: 'Blog generated using YOUR trained TOGNINJA BLOG WRITER Assistant',
        metadata: {
          method: 'assistant-first-adaptive',
          assistant_id: BLOG_ASSISTANT,
          content_length: assistantContent.length,
          parsing_success: true
        }
      };
      
    } catch (error) {
      console.error('‚ùå ASSISTANT-FIRST GENERATION FAILED:', error);
      throw error;
    }
  }
}